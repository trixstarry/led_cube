
leddriver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000118  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stab         00000c30  00000000  00000000  0000016c  2**2
                  CONTENTS, READONLY, DEBUGGING
  2 .stabstr      000007c2  00000000  00000000  00000d9c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 28 00 	jmp	0x50	; 0x50 <__ctors_end>
   4:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
   8:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
   c:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  10:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  14:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  18:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  1c:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  20:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  24:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  28:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  2c:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  30:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  34:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  38:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  3c:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  40:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  44:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  48:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>
  4c:	0c 94 32 00 	jmp	0x64	; 0x64 <__bad_interrupt>

00000050 <__ctors_end>:
  50:	11 24       	eor	r1, r1
  52:	1f be       	out	0x3f, r1	; 63
  54:	ce ef       	ldi	r28, 0xFE	; 254
  56:	d2 e0       	ldi	r29, 0x02	; 2
  58:	de bf       	out	0x3e, r29	; 62
  5a:	cd bf       	out	0x3d, r28	; 61
  5c:	0e 94 7e 00 	call	0xfc	; 0xfc <main>
  60:	0c 94 8a 00 	jmp	0x114	; 0x114 <_exit>

00000064 <__bad_interrupt>:
  64:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000068 <spi_init>:
	//Bits 1, 0 = SPR1, SPR0 =  
	//SPSR  |=   (1<<SPI2X);           // double speed operation
    */

    //ATtiny167 SPI INIT
	DDRA |= (1<<SS)|(1<<MOSI)|(1<<SCK);
  68:	81 b1       	in	r24, 0x01	; 1
  6a:	80 67       	ori	r24, 0x70	; 112
  6c:	81 b9       	out	0x01, r24	; 1
	SPCR |= (1<<SPE)|(1<<MSTR)|(1<<SPR0);
  6e:	8c b5       	in	r24, 0x2c	; 44
  70:	81 65       	ori	r24, 0x51	; 81
  72:	8c bd       	out	0x2c, r24	; 44
	SPSR |= (1<<SPI2X);
  74:	8d b5       	in	r24, 0x2d	; 45
  76:	81 60       	ori	r24, 0x01	; 1
  78:	8d bd       	out	0x2d, r24	; 45

}//spi_init
  7a:	08 95       	ret

0000007c <transmit>:
	TIMSK  |=  (1<<TOIE0);  //enable timer/counter0 overflow interrupt
	TCCR0  |=  (1<<CS00);   //normal mode, no prescale
}
*/

void transmit(uint16_t data1,uint16_t data2,uint16_t data3,uint16_t data4,uint16_t data5){
  7c:	0f 93       	push	r16
  7e:	1f 93       	push	r17
	
	uint8_t temp = 0;

	temp = (data1);
	//load first byte
	SPDR = temp;
  80:	8e bd       	out	0x2e, r24	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  82:	0d b4       	in	r0, 0x2d	; 45
  84:	07 fe       	sbrs	r0, 7
  86:	fd cf       	rjmp	.-6      	; 0x82 <transmit+0x6>

	temp = (data1>>8);
	//load second byte
	SPDR = temp;
  88:	9e bd       	out	0x2e, r25	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  8a:	0d b4       	in	r0, 0x2d	; 45
  8c:	07 fe       	sbrs	r0, 7
  8e:	fd cf       	rjmp	.-6      	; 0x8a <transmit+0xe>

	temp = (data2);
	//load third byte
	SPDR = temp;
  90:	6e bd       	out	0x2e, r22	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  92:	0d b4       	in	r0, 0x2d	; 45
  94:	07 fe       	sbrs	r0, 7
  96:	fd cf       	rjmp	.-6      	; 0x92 <transmit+0x16>

	temp = (data2>>8);
	//load fourth byte
	SPDR = temp;
  98:	7e bd       	out	0x2e, r23	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  9a:	0d b4       	in	r0, 0x2d	; 45
  9c:	07 fe       	sbrs	r0, 7
  9e:	fd cf       	rjmp	.-6      	; 0x9a <transmit+0x1e>

	temp = (data3);
	//load first byte
	SPDR = temp;
  a0:	4e bd       	out	0x2e, r20	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  a2:	0d b4       	in	r0, 0x2d	; 45
  a4:	07 fe       	sbrs	r0, 7
  a6:	fd cf       	rjmp	.-6      	; 0xa2 <transmit+0x26>

	temp = (data3>>8);
	//load second byte
	SPDR = temp;
  a8:	5e bd       	out	0x2e, r21	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  aa:	0d b4       	in	r0, 0x2d	; 45
  ac:	07 fe       	sbrs	r0, 7
  ae:	fd cf       	rjmp	.-6      	; 0xaa <transmit+0x2e>

	temp = (data4);
	//load third byte
	SPDR = temp;
  b0:	2e bd       	out	0x2e, r18	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  b2:	0d b4       	in	r0, 0x2d	; 45
  b4:	07 fe       	sbrs	r0, 7
  b6:	fd cf       	rjmp	.-6      	; 0xb2 <transmit+0x36>

	temp = (data4>>8);
	//load fourth byte
	SPDR = temp;
  b8:	3e bd       	out	0x2e, r19	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  ba:	0d b4       	in	r0, 0x2d	; 45
  bc:	07 fe       	sbrs	r0, 7
  be:	fd cf       	rjmp	.-6      	; 0xba <transmit+0x3e>

	temp = (data5);
	//load first byte
	SPDR = temp;
  c0:	0e bd       	out	0x2e, r16	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  c2:	0d b4       	in	r0, 0x2d	; 45
  c4:	07 fe       	sbrs	r0, 7
  c6:	fd cf       	rjmp	.-6      	; 0xc2 <transmit+0x46>

	temp = (data5>>8);
	//load second byte
	SPDR = temp;
  c8:	1e bd       	out	0x2e, r17	; 46
	//temp = 0x0F & display_count;
	while(bit_is_clear(SPSR,SPIF)){};
  ca:	0d b4       	in	r0, 0x2d	; 45
  cc:	07 fe       	sbrs	r0, 7
  ce:	fd cf       	rjmp	.-6      	; 0xca <transmit+0x4e>
    
	//Toggle latch
	PORTA |= (1<<SS);
  d0:	16 9a       	sbi	0x02, 6	; 2
	PORTA &= ~(1<<SS);
  d2:	16 98       	cbi	0x02, 6	; 2
}
  d4:	1f 91       	pop	r17
  d6:	0f 91       	pop	r16
  d8:	08 95       	ret

000000da <patrick_test>:

void patrick_test(void){
  da:	0f 93       	push	r16
  dc:	1f 93       	push	r17
    uint16_t data2 = 0x00FF;
    uint16_t data3 = 0x00FF;
    uint16_t data4 = 0x00FF;
    uint16_t data5 = 0x00FF;

    transmit(data1,data2,data3,data4,data5);
  de:	8f ef       	ldi	r24, 0xFF	; 255
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	6f ef       	ldi	r22, 0xFF	; 255
  e4:	70 e0       	ldi	r23, 0x00	; 0
  e6:	4f ef       	ldi	r20, 0xFF	; 255
  e8:	50 e0       	ldi	r21, 0x00	; 0
  ea:	2f ef       	ldi	r18, 0xFF	; 255
  ec:	30 e0       	ldi	r19, 0x00	; 0
  ee:	0f ef       	ldi	r16, 0xFF	; 255
  f0:	10 e0       	ldi	r17, 0x00	; 0
  f2:	0e 94 3e 00 	call	0x7c	; 0x7c <transmit>
}
  f6:	1f 91       	pop	r17
  f8:	0f 91       	pop	r16
  fa:	08 95       	ret

000000fc <main>:
	//Bits 1, 0 = SPR1, SPR0 =  
	//SPSR  |=   (1<<SPI2X);           // double speed operation
    */

    //ATtiny167 SPI INIT
	DDRA |= (1<<SS)|(1<<MOSI)|(1<<SCK);
  fc:	81 b1       	in	r24, 0x01	; 1
  fe:	80 67       	ori	r24, 0x70	; 112
 100:	81 b9       	out	0x01, r24	; 1
	SPCR |= (1<<SPE)|(1<<MSTR)|(1<<SPR0);
 102:	8c b5       	in	r24, 0x2c	; 44
 104:	81 65       	ori	r24, 0x51	; 81
 106:	8c bd       	out	0x2c, r24	; 44
	SPSR |= (1<<SPI2X);
 108:	8d b5       	in	r24, 0x2d	; 45
 10a:	81 60       	ori	r24, 0x01	; 1
 10c:	8d bd       	out	0x2d, r24	; 45
	spi_init();    //initalize SPI port
    //PORTB = 0x02;
	//sei();         //enable interrupts before entering loop
    uint8_t input = 0;
	while(1){
        patrick_test();
 10e:	0e 94 6d 00 	call	0xda	; 0xda <patrick_test>
 112:	fd cf       	rjmp	.-6      	; 0x10e <main+0x12>

00000114 <_exit>:
 114:	f8 94       	cli

00000116 <__stop_program>:
 116:	ff cf       	rjmp	.-2      	; 0x116 <__stop_program>
